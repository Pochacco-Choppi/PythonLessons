## Введение: Ошибки и исключения

Во время написания программ мы можем столкнуться с тем что наша программа вылетает либо просто не хочет запускаться.

Если вы учите Python недавно, то я думаю вы не раз видели такую ошибку как `Syntax Errors`, ниже приведен пример кода который может вызвать данную ошибку:

```python
while True print("Hello world")
```

Если мы попытаемся запустить код выше мы получим ошибку с таким описанием:

```python
  File "C:\Users\Jaroslaw\Desktop\Python lessons\rrr.py", line 1
    while True print("Hello world")
               ^
SyntaxError: invalid syntaxntax
```

Давайте разберем наше сообщение об ошибке: 

В первой строке мы можем понять в каком **файле/модуле и на какой строке** произошло наше исключение, в нашем случае это 1 строка; 
Ниже **наш код** с подсказкой места в каком месте произошло это исключение;
На последней строке **название**  **исключения** - `SyntaxError`.



Давайте посмотрим еще какие исключения могут встретиться при выполнении программ:

```python
# Ошибка 1
10 * (1/0)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero

# Ошибка 2
4 + spam*3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'spam' is not defined

# Ошибка 3
'2' + 2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can only concatenate str (not "int") to str
```

**Первое** исключение заключается в том, что мы попытались поделить на 0, что привело к поломке нашей программы.

**Второе** исключение произошло по причине того, что мы обращаемся к переменной spam которая нигде не объявлена в нашей программе.

**Третье** исключение говорит нам о том что мы не можем сложить строку и число. 



Все эти ошибки приводят к завершению выполнения нашей программы, а это явно не то что мы хотим. Для того чтобы наша программа не завершала свое выполнение мы должны обработать данные участки кода, для этого в Python существует конструкция **try/except/else/finally**,

Посмотрите на код ниже и подумайте какая ошибка может произойти при выполнении данной программы:

```python
while True:
    num = int(input("Введите число: "))
    print(num)
```

Если вы сказали `ValueError` то вы правы, может быть такой вариант что пользователь вместо числа введет строку/число+букву и тогда наша программа завершит свое выполнение т.к. `int(obj)` не умеет работать со строками по типу "one".

Текст ошибки можно посмотреть ниже:

```python
Введите число: one

Traceback (most recent call last):
  File "C:\Users\Jaroslaw\Desktop\Python lessons\example.py", line 2, in <module>
    num = int(input("Введите число: "))
ValueError: invalid literal for int() with base 10: 'one'
```

Давайте обработаем данную ошибку используя конструкцию **try/except**:

```python
while True:
    try:
        num = int(input("Введите число: "))
        print(num)
    except ValueError:
        print("Ой, произошла ошибка!")
```

Теперь наша программа не будет завершаться, а будет выводить сообщение "Ой, произошла ошибка!" и продолжать свою работу.



Запомним как выглядит конструкция **try/except/else**:

```python
try:
    # Блок кода который может вызвать исключение
except НАЗВАНИЕ_ОЖИДАЕМОЙ_ОШИБКИ:
    # Блок кода который обрабатывает это исключение
except НАЗВАНИЕ_ОЖИДАЕМОЙ_ОШИБКИ:
    # Блок кода который обрабатывает это исключение
...
except НАЗВАНИЕ_ОЖИДАЕМОЙ_ОШИБКИ:
    # Блок кода который обрабатывает это исключение
else:
    # Код, который выполнится если исключение отсутствует
finally:
    # Код, который выполнится в любом случае
```

Мы можем **вызывать исключения** своими руками используя ключевое слово `raise`:

```python
raise ValueError("Woops!") # Вызовет ошибку ValueError.
```

Если вы пишете свой модуль или библиотеку, может возникнуть ситуация когда вам захочется создать **свой класс исключений**, для этого нам нужно будет наследоваться от базового класса  **Exeption**:

```python
class MySuperMegaError(Exception):
    pass
```
